import importlib
import inspect
import warnings


from ..description import ProcessDescription
from .ProcessRunnerContext import ProcessRunnerContext


class ProcessRunner(object):

    def __init__(self):
        self._pd = None
        self._state_functions = dict()
        self._transition_functions = dict()

    @property
    def process_description(self):
        return self._pd

    def states(self):
        return self._pd.states()

    def transitions(self):
        return self._pd.transitions()

    def get_state(self, name):
        return self._pd.get_state(name)

    def get_transition(self, name_from, name_to):
        return self._pd.get_transition(name_from, name_to)

    @classmethod
    def from_process_description(cls, process_description):
        """
        Create a runner from a ProcessDescription
        No real functions are loaded
        :return: new instance of ProcessRunner
        """
        runner = cls()
        runner._pd = process_description
        return runner

    @classmethod
    def from_python(cls, module_name):
        """
        Create a runner from the .py file generated by ProcessDescription.render_code()
        Any functions from the file will be loaded as well
        :param module_name: str, the python module, e.g. "package.file"
        :return: new instance of ProcessRunner
        """
        module = importlib.import_module(module_name)
        objects = module.__dict__
        if "TRANSITIONS" not in objects:
            raise ValueError("TRANSITIONS not found in module %s" % module_name)

        pd = ProcessDescription()
        pd.set_transitions(objects["TRANSITIONS"])

        runner = cls.from_process_description(pd)
        runner.load_functions(module_name)

        return runner

    def load_functions(self, module_name):
        """
        Load the state and transitions functions from the python module
        :param module_name: str, the python module, e.g. "package.file"
        :return: None
        """
        module = importlib.import_module(module_name)

        func_name_to_state = {s.function_name: s for s in self._pd.states()}
        func_name_to_transition = {t.function_name: t for t in self._pd.transitions()}

        def _doc_equal(obj, doc):
            lines1 = list(line.strip() for line in inspect.getdoc(obj).strip().split("\n") if line.strip())
            lines2 = list(line.strip() for line in doc.strip().split("\n") if line.strip())
            return lines1 == lines2

        for name in module.__dict__:
            obj = module.__dict__[name]
            if inspect.isfunction(obj):
                if name.startswith("state_"):
                    if name not in func_name_to_state:
                        raise ValueError("state function '%s' is unused" % name)
                    state = func_name_to_state[name]
                    if not _doc_equal(obj, state.python_doc):
                        warnings.warn("doc-string changed for state function '%s':\n%s" % (name, state.python_doc))
                    self._state_functions[func_name_to_state[name].name] = obj

                if name.startswith("transition_"):
                    if name not in func_name_to_transition:
                        raise ValueError("transition function '%s' is unused" % name)
                    t = func_name_to_transition[name]
                    if not _doc_equal(obj, t.python_doc):
                        warnings.warn("doc-string changed for transition function '%s':\n%s" % (name, t.python_doc))
                    self._transition_functions[(t.name_from, t.name_to)] = obj

    def get_state_function(self, state_name):
        return self._state_functions.get(state_name, None)

    def get_transition_function(self, state_name_from, state_name_to):
        return self._transition_functions.get((state_name_from, state_name_to), None)

    def create_context(self, state_name, **kwargs):
        state = self._pd.get_state(state_name)
        context = ProcessRunnerContext(self, state, **kwargs)
        return context
